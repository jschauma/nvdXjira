#! /usr/bin/env python2.7
#
# This little tool reads input in XML format of NIST's NVD and creates new
# tickets for any CVEs not found in Jira.
#
# Copyright (c) 2013, Twitter, Inc. All rights reserved.
#
# Originally written by Jan Schaumann <jschauma@twitter.com> in April
# 2013.

import BaseHTTPServer
import datetime
import getopt
import grp
import json
import os
import random
import re
import smtplib
import sys
import urllib
import urllib2
import xml

import xml.etree.ElementTree as ET

from email.mime.text import MIMEText

SUPPORTED_ACTIONS = {
    "label-actions" : {
        "blocker"      : True,
        "mail"         : True
    },
    "swactions" : {
        "assign"       : True,
        "blocker"      : True,
        "cancel"       : True,
        "mail"         : True,
        "watch"        : True
    }
}

TICKETS = []

DEFAULTS = {
    "apiurl"           : "/rest/api/latest/",
    "assign-threshold" : 24 * 60 * 60,          # 24h in seconds
    "config"           : "/etc/nvdXjira/config",
    "cve-threshold"    : 8 * 7 * 24 * 60 * 60,  # 8w in seconds
    "debug"            : False,
    "label-actions"    : "/etc/nvdXjira/label-actions",
    "nag-threshold"    : 2 * 7 * 24 * 60 * 60,  # 2w in seconds
    "password"         : "",
    "project"          : "VULN",
    "reject"           : "/etc/nvdXjira/reject-patterns",
    "swactions"        : "/etc/nvdXjira/software-actions",
    "tag"              : "cve",
    "triage-group"     : "cve-ticket-handlers",
    "update"           : False,
    "url"              : "https://jira.twitter.biz",
    "username"         : ""
}

EXIT_FAILURE = 1
EXIT_SUCCESS = 0

NAMESPACES = {
    'def'  : 'http://scap.nist.gov/schema/feed/vulnerability/2.0',
    'vuln' : 'http://scap.nist.gov/schema/vulnerability/0.4',
    'cvss' : 'http://scap.nist.gov/schema/cvss-v2/0.2'
}

###
### Classes
###

class CVE(object):
    """A simple CVE object.  Its fields are 'interesting' bits of
    information about a CVE."""

    def __init__(self):
        """Construct a CVE with default values."""
        self.vulnfields = [ "last-modified-datetime",
                            "published-datetime",
                            "summary" ]
        self.cvssfields = [ "access-complexity",
                            "access-vector",
                            "authentication",
                            "availability-impact",
                            "confidentiality-impact",
                            "integrity-impact",
                            "score" ]
        self.data = {}
        for field in self.vulnfields + self.cvssfields:
            self.data[field] = ""
        self.data['urls'] = []
        self.data['vulnerable-software-list'] = []


    def __repr__(self):
        descr = "%s\n" % self.data['id']
        keys = self.data.keys()
        keys.sort()
        for k in keys:
            val = self.data[k]
            if type(val) == list:
                val = ",".join(val)
            descr += "%s : %s\n" % (k.ljust(25), val)

        return descr



class NVDXJIRA(object):

    def __init__(self):
        """Construct a NVDXJIRA with default values."""
        self.config = DEFAULTS
        self.frobbed = dict((x, False) for x in self.config.keys())
        self.actions = {
            "label-actions" : {},
            "swactions"     : {}
        }
        self.reject_patterns = {}
        self.verbosity = 0


    class Usage(Exception):
        """A simple exception that provides a usage statement and a return
        code."""

        def __init__(self, rval):
            self.err = rval
            self.msg = 'Usage: %s [-Dhuv] [[-cls] file]' % os.path.basename(sys.argv[0])
            self.msg += ' [-j url] [-p project] [-t tag]\n'
            self.msg += '\t-D          run in debug mode, no tickets are created/updated\n'
            self.msg += '\t-c file     read configuration from this file\n'
            self.msg += '\t-h          print this message and exit\n'
            self.msg += '\t-j url      jira base URL\n'
            self.msg += '\t-l file     read label actions from this file\n'
            self.msg += '\t-p project  jira project to create tickets in\n'
            self.msg += '\t-r file     read regular expressions to auto-close tickets from this file\n'
            self.msg += '\t-s file     read actions for software matching patterns from this file\n'
            self.msg += '\t-t tag      label to tag new tickets with\n'
            self.msg += '\t-u          update existing tickets only\n'
            self.msg += '\t-v          increase verbosity\n'


    def addCommentToTicket(self, comment, ticket, cookie):
        """Add a comment to the ticket."""
        url = self.config["url"] + self.config["apiurl"] + "issue/" + ticket

        self.verbose("Adding the following comment to ticket '%s'..." % ticket, 3)
        self.verbose(comment, 3)
        data = {
                "update" : {
                    "comment" : [
                        {
                            "add": {
                                "body": comment
                            }
                        }
                    ]
                }
        }
        self.jiraRequest(url, data, cookie, "PUT")


    def addWatchers(self, ticket, watchers, cookie, reason="N/A"):
        """Add watchers to the given ticket."""

        self.verbose("Adding watchers (%s) to ticket %s..." % (ticket, watchers))
        self.verbose("Getting current watchers for ticket '%s'..." % ticket, 2)

        url = self.config["url"] + self.config["apiurl"] + "issue/" + ticket + "/watchers"
        res = self.jiraRequest(url, None, cookie, "GET")
        if not res:
            sys.stderr.write("No data returned from %s.\n" % url)
            return

        ticket_watchers = []
        data = json.loads(res.readline())
        if data.has_key("watchers"):
            ticket_watchers = map(lambda(x): x["name"], data["watchers"])

        for current_watcher in ticket_watchers:
            if current_watcher in watchers:
                self.verbose("%s already watching %s." % (current_watcher, ticket), 3)
                watchers.remove(current_watcher)

        for watcher in watchers:
            self.jiraRequest(url, watcher, cookie, "POST")
            self.verbose("Added watcher (%s) to ticket %s." % (watcher, ticket), 3)


    def applyLabelActions(self, jira_data, cookie):
        """Iterate over the regular expressions and label actions and
           perform the requested actions if any of the labels on this
           ticket match.
        """

        ticket = jira_data["key"]
        self.verbose("Applying label actions to ticket %s..." % ticket, 2)

        blockers = {}

        for label in jira_data["fields"]["labels"]:
            self.verbose("Checking label %s..." % label, 3)
            for a in self.actions["label-actions"].keys():
                pattern = re.compile(a.pattern)
                self.verbose("Checking if %s matches %s..." % (label, a.pattern), 4)
                if pattern.match(label):
                    self.verbose("%s matched %s." % (label, a.pattern), 4)

                    if a.action.startswith("blocker:"):
                        if blockers.has_key(a.pattern):
                            continue
                        blockers[a.pattern] = True
                        project = a.action[a.action.find(':') + 1:]
                        self.createBlocker(jira_data, project, cookie)

                    elif a.action.startswith("mail:"):
                        recipient = a.action[a.action.find(':') + 1:]
                        if not self.mailSent(jira_data, recipient):
                            self.sendMail(a.pattern, recipient, jira_data, cookie)



    def applySoftwareActions(self, swlist, jira_data, cookie):
        """Iterate over the regular expressions and software actions and
           close/update the ticket the vulnerable software list matches the
           action pattern.

           This process isn't quite as straightforward as one would like:
           A given CVE may apply to a number of different pieces of
           software.  We do not want to close the ticket just because one
           of the various vulnerable software versions is found.  Instead,
           we only cancel a ticket if _all_ of the vulnerable software
           versions match the given cancel pattern.
        """

        assert(type(swlist) == list)

        ticket = jira_data["key"]

        self.verbose("Applying software actions to ticket %s..." % ticket, 2)

        if not len(swlist):
            self.verbose("No software list found.", 3)
            return

        comments = {}
        matching = 0
        blockers = {}
        continue_checking = True

        for vulnerable_software in swlist:
            self.verbose("Checking listed software '%s'..." % vulnerable_software, 3)

            if not continue_checking:
                break

            for s in self.actions["swactions"].keys():
                p = re.compile(s.pattern)
                self.verbose("Checking if '%s' matches '%s'..." % (s.pattern, vulnerable_software), 4)
                if p.match(vulnerable_software):
                    self.verbose("Affected software matched pattern '%s'." % s.pattern, 4)
                    if s.action == "cancel":
                        matching += 1
                        comments[s.pattern] = True
                        if s.comment:
                            comments[s.comment] = True
                        # we can only cancel once; no other actions take
                        # place once we cancelled
                        break

                    elif s.action.startswith("assign:"):
                        if not jira_data["fields"]["assignee"]:
                            comment = "Default assignee for vulnerable software matching '%s'." % s.pattern
                            if s.comment:
                                comment = s.comment
                            assignee = s.action[s.action.find(':') + 1:]
                            self.assignTicket(ticket, assignee, cookie, comment)
                            continue_checking = False
                            # we can only assign once; first entry wins
                            break

                    elif s.action.startswith("blocker:"):
                        if blockers.has_key(s.pattern):
                            continue
                        blockers[s.pattern] = True
                        project = s.action[s.action.find(':') + 1:]
                        self.createBlocker(jira_data, project, cookie)

                    elif s.action.startswith("mail:"):
                        recipient = s.action[s.action.find(':') + 1:]
                        if not self.mailSent(jira_data, recipient):
                            self.sendMail(s.pattern, recipient, jira_data, cookie)
                            continue_checking = False

                    elif s.action.startswith("watch:"):
                            comment = "Adding watchers per software pattern '%s'." % s.pattern
                            if s.comment:
                                comment = s.comment
                            watchers = s.action[s.action.find(':') + 1:].split(",")
                            self.addWatchers(ticket, watchers, cookie, comment)
                            continue_checking = False


        if matching == len(swlist):
            comment = "All affected software found in cancel patterns.\n"
            comment += "\n"
            comment += "\n".join(comments.keys())
            self.closeTicket(ticket, cookie, comment)


    def assignTicket(self, ticket, assignee, cookie, reason="N/A"):
        """Assign the given ticket to the assignee."""

        self.verbose("Assigning ticket %s to %s (%s)..." % (ticket, assignee, reason))
        url = self.config["url"] + self.config["apiurl"] + "issue/" + ticket
        data = {
            "update" : {
                "comment" : [
                    {
                        "add": {
                            "body": reason
                        }
                    }
                ]
            },
            "fields" : {
                "assignee" : {
                    "name": "%s" % assignee
                }
            },
        }

        self.jiraRequest(url, data, cookie, "PUT")
        self.verbose("Assigned ticket %s to %s." % (ticket, assignee), 3)


    def closeIfRejected(self, cve_data, ticket, cookie):
        """Close the ticket if the body body matches the reject
           pattern.  Returns True if the ticket was closed."""

        self.verbose("Closing ticket %s if necessary..." % ticket, 2)
        for pattern in self.reject_patterns.keys():
            self.verbose("Checking pattern: '%s'" % pattern, 2)
            p = re.compile(pattern)
            m = p.match(cve_data["summary"])
            if m:
                self.closeTicket(ticket, cookie, "Matched reject pattern '%s'." % pattern)
                return True
        return False


    def closeTicket(self, ticket, cookie, reason="N/A"):
        """Close the given ticket appending an optional reason."""

        self.verbose("Closing ticket %s (%s)..." % (ticket, reason), 3)

        url = self.config["url"] + self.config["apiurl"] + "issue/" + ticket + "/transitions"
        data = {
            "update" : {
                "comment" : [
                    {
                        "add": {
                            "body": reason
                        }
                    }
                ]
            },
            "fields" : {
                "resolution" : {
                    "name": "Cancelled"
                }
            },
            "transition" : {
                "id" : "5"
            }
        }
        self.jiraRequest(url, data, cookie)
        self.verbose("Closed ticket %s." % ticket, 3)


    def createBlocker(self, jira_data, project, cookie):
        """Create a blocker ticket in the given project."""

        ticket = jira_data["key"]
        cve_pattern = re.compile("(?P<cve_id>CVE-[0-9]+-[0-9]+)")
        cve_id = ""
        m = cve_pattern.search(jira_data["fields"]["summary"])
        if m:
            cve_id = m.group("cve_id")

        summary = "Please investigate %s (%s)" % (cve_id, ticket)

        self.verbose("Checking for existing blocker tickets in %s for CVE %s..." % (project, cve_id), 2)
        for link in jira_data["fields"]["issuelinks"]:
            key = ""
            if link["type"]["name"] == "Blocker" and link.has_key("inwardIssue") and \
                link["inwardIssue"]["key"].startswith("%s-" % project) and \
                link["inwardIssue"]["fields"]["summary"].startswith(summary):
                self.verbose("%s already blocked by %s." % (ticket, link["inwardIssue"]["key"]), 2)
                return

        self.verbose("Creating blocker ticket in %s for CVE %s..." % (project, cve_id), 2)

        description = summary
        description += "\n\n%s\n" % jira_data["fields"]["description"]

        blocker = self.createTicket(project, summary, description, [ self.config["tag"] ], cookie)

        self.verbose("Linking new ticket %s as a blocker for %s..." % (blocker["key"], ticket), 3)
        url = self.config["url"] + self.config["apiurl"] + "issueLink"
        data = {
            "type" : { "name": "Blocker" },
            "inwardIssue" : { "key" : blocker["key"] },
            "outwardIssue" : { "key" : ticket }
        }
        self.jiraRequest(url, data, cookie, "POST")


    def createOrUpdateTickets(self, cookie):
        """Parse the input and create new or update existing tickets from
           that data."""

        self.verbose("Creating or updating tickets...")
        for cve in self.getCVEs():
            cve_id = cve.data["id"]
            published = cve.data["published-datetime"]
            if self.olderThan(published, self.config["cve-threshold"]):
                self.verbose("Ignoring %s published on %s." % (cve_id, published))
                continue

            print_data = ""
            tickets = self.getTickets("project=%s%%20AND%%20summary~%s&fields=*all" % \
                                           (self.config["project"], cve_id), cookie)

            if not tickets:
                labels = [ self.config["tag"] ]
                description = cve.data["summary"]
                description += "\n\n{noformat}\n%s\n{noformat}\n" % cve
                description += "\n\nhttps://cve.mitre.org/cgi-bin/cvename.cgi?name=%s\n" % cve_id
                summary = cve_id
                if cve.data["score"]:
                    summary += " (CVSS: %s)" % cve.data["score"]
                    labels.append("cvss-%s" % cve.data["score"])

                ticket = self.createTicket(self.config["project"], summary, description, labels, cookie)
                if not self.config["debug"]:
                    print_data = ticket["key"]
                    tickets = [ ticket ]

            for ticket in tickets:
                self.updateTicket(cve, ticket, cookie)
                self.linkExistingTickets(ticket["key"], cve_id, cookie)

            if self.config["debug"] and print_data:
                self.printInfo(cve, print_data)


    def createTicket(self, project, summary, description, labels, cookie):
        """Create a new Jira ticket with the given data."""

        ticket = ""
        self.verbose("Creating ticket: %s..." % summary, 2)

        if self.config["debug"]:
            sys.stderr.write("%s\n%s\n%s\n%s\n" % ( project, summary, description, labels))

        url = self.config["url"] + self.config["apiurl"] + "issue/"
        data = {
            "fields" : {
                "project"     : {
                    "key"     : "%s" % project
                    },
                "summary"     : summary,
                "description" : description,
                "labels"      : labels,
                "issuetype"   : { "name" : "Task" }
                }
            }
        res = self.jiraRequest(url, data, cookie)
        if not self.config["debug"]:
            data = json.loads(res.readline())
            if data.has_key("key"):
                self.verbose("Successfully created ticket %s." % data["key"], 3)

        return data


    def getCVEs(self):
        """Parse the input (expected to be valid NVD XML) and extract all CVEs.

        Returns a list of CVE objects."""

        self.verbose("Getting CVEs from input...")
        xml = self.parseInput()

        cves = []

        self.verbose("Walking XML tree...")
        root = xml.getroot()
        for child in root.findall('./{%s}entry' % NAMESPACES['def']):
            cve = CVE()
            cve.data['id'] = child.attrib['id']

            self.verbose("Processing %s..." % cve.data['id'], 2)

            for field in cve.vulnfields:
                node = child.find('./{%s}%s' % (NAMESPACES['vuln'], field))
                cve.data[field] = node.text

            swlist = child.find('./{%s}vulnerable-software-list' % NAMESPACES['vuln'])
            if swlist is not None:
                for sw in swlist.findall('./{%s}product' % NAMESPACES['vuln']):
                    cve.data['vulnerable-software-list'].append(sw.text)

            for ref in child.findall('./{%s}references' % NAMESPACES['vuln']):
                r = ref.find('./{%s}reference' % NAMESPACES['vuln'])
                if r is not None:
                    cve.data['urls'].append(r.attrib['href'])

            cvss = child.find('./{%s}cvss/{%s}base_metrics' % (NAMESPACES['vuln'],
                                                                NAMESPACES['cvss']))
            if cvss is not None:
                for field in cve.cvssfields:
                    node = cvss.find('./{%s}%s' % (NAMESPACES['cvss'], field))
                    if node is not None:
                        cve.data[field] = node.text
                    else:
                        sys.stderr.write("Unable to find cvss field '%s' for %s" % (field, cve.data['id']))

            cves.append(cve)
        return cves


    def getJiraCookie(self):
        """Log in to the Jira API and retrieve a cookie."""

        url = self.config["url"] + "/rest/auth/latest/session"
        self.verbose("Logging in to Jira at %s as %s..." % (url, self.config["username"]))
        credentials = { 'username' : self.config["username"],
                        'password' : self.config["password"] }
        data = json.dumps(credentials).encode()
        headers = { 'Content-Type' : 'application/json',
                    'Accept' : 'application/json' }

        try:
            req = urllib2.Request(url, data, headers)
            res = urllib2.urlopen(req)
        except urllib2.HTTPError, e:
            sys.stderr.write("Unable to fetch '%s': %s %s\n" % \
                                (url, e.code, BaseHTTPServer.BaseHTTPRequestHandler.responses[e.code][0]))
            sys.exit(EXIT_FAILURE)

        data = json.loads(res.readline())
        return data["session"]


    def getNewTicketOwner(self):
        """Return a random member of the triaging group."""

        try:
            group = grp.getgrnam(self.config["triage-group"])
        except KeyError, e:
            sys.stderr.write("Unable to get group %s.\n" % self.config["triage-group"])
            return None

        return random.choice(group.gr_mem)


    def getSoftwareListFromTicketData(self, jira_data):
        """Return a string of vulnerable data as extracted from the input
           data's description or comments."""

        self.verbose("Getting list of vulnerable software from Jira data...", 3)

        swpattern = re.compile("\nvulnerable[_-]software[_-]list\s*: (?P<sw>.+?)\n")
        desc = jira_data["fields"]["description"]

        m = swpattern.search(desc)
        if m:
            sw = m.group("sw")
            self.verbose("Found vulnerable software: %s." % sw, 4)
            return sw.split(",")

        if jira_data["fields"].has_key("comment"):
            for comment in jira_data["fields"]["comment"]["comments"]:
                m = swpattern.search(comment["body"])
                if m:
                    sw = m.group("sw")
                    self.verbose("Found vulnerable software: %s." % sw, 4)
                    return sw.split(",")

        return []


    def getTicketData(self, ticket, cookie):
        """Return the json data for the given ticket."""

        self.verbose("Getting Jira json data for ticket '%s'..." % ticket, 3)

        url = self.config["url"] + self.config["apiurl"] + "issue/" + ticket
        res = self.jiraRequest(url, None, cookie, "GET")
        if not res:
            sys.stderr.write("No data returned from %s.\n" % url)
            return None

        return json.loads(res.readline())


    def getTickets(self, query, cookie):
        """Query Jira for all tickets mentioning this CVE and return them."""

        self.verbose("Searching Jira tickets with query '%s'..." % query, 2)
        ticket_keys = []

        url = self.config["url"] + self.config["apiurl"] + "search?jql=%s" % query
        self.verbose("Searching Jira tickets using %s..." % url, 3)
        headers = { 'Content-Type' : 'application/json',
                    'Accept' : 'application/json',
                    'Cookie' : '%s=%s' % (cookie["name"], cookie["value"]) }

        try:
            req = urllib2.Request(url, None, headers)
            res = urllib2.urlopen(req)
        except urllib2.HTTPError, e:
            sys.stderr.write("Unable to fetch '%s': %s %s\n" % \
                                (url, e.code, BaseHTTPServer.BaseHTTPRequestHandler.responses[e.code][0]))
            sys.exit(EXIT_FAILURE)

        data = json.loads(res.readline())
        for t in data["issues"]:
            ticket_keys.append(t["key"])

        self.verbose("Returning the following %d tickets: %s" % (len(ticket_keys), ", ".join(ticket_keys)), 2)
        return data["issues"]


    def jiraRequest(self, url, data, cookie, method="POST"):

        res = None
        self.verbose("Making Jira %s request to %s..." % (method, url), 2)

        if data:
            data = json.dumps(data).encode()

        if method == "POST":
            self.verbose("Posting data to %s..." % url, 3)
            self.verbose(data, 3)

        if self.config["debug"] and method != "GET":
            sys.stderr.write(data + "\n")
        else:
            headers = { 'Content-Type' : 'application/json',
                        'Accept' : 'application/json',
                        'Cookie' : '%s=%s' % (cookie["name"], cookie["value"]) }

            try:
                req = urllib2.Request(url, data, headers)
                if method != "POST":
                    req.get_method = lambda: method
                res = urllib2.urlopen(req)
            except urllib2.HTTPError, e:
                # XXX: data = json.loads(res.readline())
                sys.stderr.write("Unable to make Jira request at '%s': %s %s\n" % \
                                (url, e.code, BaseHTTPServer.BaseHTTPRequestHandler.responses[e.code][0]))
                sys.stderr.write("Data posted:\n%s\n" % data)
                sys.exit(EXIT_FAILURE)

        if method == "PUT":
            if not self.config["debug"]:
                if res.getcode() == 204:
                    self.verbose("Successfully updated Jira.", 3)
                else:
                    sys.stderr.write("Unable to update Jira.\n")
                    sys.stderr.write("Got: %d\n" % res.getcode())

        return res


    def linkExistingTickets(self, ticket, cve_id, cookie, linkType="Related"):
        """Search for existing tickets referencing the given CVE, then link
           them to the project specific tickets."""

        self.verbose("Linking any existing tickets for %s..." % cve_id, 2)

        existing_tickets = self.getTickets("text~%s%%20AND%%20!(project=%s%%20AND%%20summary~%s)" % \
                                           (cve_id, self.config["project"], cve_id), cookie)

        for t in existing_tickets:
            self.verbose("Checking existence of link between %s and %s..." % (t["key"], ticket), 3)
            found = False
            for link in t["fields"]["issuelinks"]:
                key = ""
                if link.has_key("outwardIssue"):
                    key = link["outwardIssue"]["key"]
                elif link.has_key("inwardIssue"):
                    key = link["inwardIssue"]["key"]
                if key == ticket:
                    self.verbose("%s already linked to %s..." % (t["key"], ticket), 3)
                    found = True
                    break

            if not found:
                self.verbose("Linking %s to %s..." % (t, ticket), 3)
                url = self.config["url"] + self.config["apiurl"] + "issueLink"
                data = {
                    "type" : { "name": linkType },
                    "inwardIssue" : { "key" : t["key"] },
                    "outwardIssue" : { "key" : ticket }
                }
                self.jiraRequest(url, data, cookie, "POST")



    def parseConfigFile(self):
        """Parse the configuration file and update any settings that were
        not specified on the command-line."""

        cfg = self.config["config"]
        if not self.frobbed["config"] and not os.path.exists(cfg):
            return

        self.verbose("Parsing config file ('%s')..." % cfg)

        n = 0
        keyval = re.compile("(?P<key>.+?)\s*=\s*(?P<val>.+)")

        try:
            f = open(cfg, 'r')
            for line in f.readlines():
                n += 1
                line = re.sub(r'#.*', '', line).strip()
                if line:
                    m = keyval.match(line)
                    if not m:
                        sys.stderr.write("Ignoring invalid syntax in line %d: '%s'\n" % (n, line))
                    else:
                        key = m.group('key').strip()
                        val = m.group('val').strip()
                        if self.config.has_key(key):
                            # Only overwrite parameters that were not
                            # changed via command-line flags.
                            if not self.frobbed[key]:
                                self.setConfigOption(key, val)
                                # Do not leak an actual password onto the
                                # terminal or into logs.
                                if key == "password":
                                    val = "XXXXXX"
                                self.verbose("Setting %s to %s..." % (key, val), 2)
                        else:
                            sys.stderr.write("Ingoring unknown configuration parameter '%s'.\n" % key)
            f.close()

        except IOError, e:
            sys.stderr.write("Unable to read '%s': %s\n" % (cfg, e.strerror))
            sys.exit(EXIT_FAILURE)


    def mailSent(self, jira_data, recipient):
        """Establish if mail was already sent to the specified recipient
           by looking at any comments."""

        sent_pattern = re.compile("Sent mail to.*%s" % recipient, re.I)

        self.verbose("Checking if we already sent mail to %s..." % recipient, 4)

        if jira_data["fields"].has_key("comment"):
            for comment in jira_data["fields"]["comment"]["comments"]:
                m = sent_pattern.search(comment["body"])
                if m:
                    self.verbose("Already sent mail to %s." % recipient, 4)
                    return True
        return False


    def parseInput(self):
        """Read input (yes, all in one), and parse as XML.
           Operates on stdin, returns an xml.etree.ElementTree"""

        self.verbose("Parsing input as XML...", 2)
        try:
            tree = ET.parse(sys.stdin)
        except xml.parsers.expat.ExpatError, e:
            sys.stderr.write("Unable to parse input as valid XML: %s\n" % e.args[0])
            sys.exit(EXIT_ERROR)
            # NOTREACHED

        return tree


    def parseOptions(self, inargs):
        """Parse given command-line optoins and set appropriate
        attributes.

        Arguments:
            inargs -- arguments to parse

        Raises:
            Usage -- if '-h' or invalid command-line args are given
        """

        global TICKETS

        try:
            opts, args = getopt.getopt(inargs, "Dc:d:hj:l:no:p:r:s:t:uv")
        except getopt.GetoptError:
            raise self.Usage(EXIT_FAILURE)

        for option, argument in opts:
            if option in ("-D"):
                self.setConfigOption("debug", True)
            if option in ("-c"):
                self.setConfigOption("config", argument)
            if option in ("-h"):
                raise self.Usage(EXIT_SUCCESS)
            if option in ("-j"):
                self.setConfigOption("url", argument)
            if option in ("-l"):
                self.setConfigOption("label-actions", argument)
            if option in ("-p"):
                self.setConfigOption("project", argument)
            if option in ("-r"):
                self.setConfigOption("reject", argument)
            if option in ("-s"):
                self.setConfigOption("swactions", argument)
            if option in ("-t"):
                self.setConfigOption("tag", argument)
            if option in ("-u"):
                self.setConfigOption("update", True)
            if option in ("-v"):
                self.verbosity += 1

        if args:
            if not self.config["update"]:
                raise self.Usage(EXIT_FAILURE)
            else:
                TICKETS = args


    def parseRejectFile(self):
        """Parse the file containing regular expressions based on which we
           want to automatically close tickets."""

        rejectFile = self.config['reject']
        self.verbose("Parsing reject file ('%s')..." % rejectFile)

        try:
            f = open(rejectFile, 'r')
            for line in f.readlines():
                line = re.sub(r'^#.*', '', line).strip()
                if line:
                    self.reject_patterns[line.strip()] = True
            f.close()

            self.verbose("Found the following reject patterns:", 3)
            for pattern in self.reject_patterns.keys():
                self.verbose("'%s'" % pattern, 3)

        except IOError, e:
            sys.stderr.write("Unable to read '%s': %s\n" % (rejectFile, e.strerror))
            sys.exit(EXIT_FAILURE)


    def parseActionsFile(self, which):
        """Parse the file containing actions and regular expressions to
        match against the 'vulernable software list'."""

        actionsFile = self.config[which]
        self.verbose("Parsing %s file ('%s')..." % (which, actionsFile))

        try:
            f = open(actionsFile, 'r')
        except IOError, e:
            sys.stderr.write("Unable to read '%s': %s\n" % (actionsFile, e.strerror))
            sys.exit(EXIT_FAILURE)

        n = 0
        for line in f.readlines():
            comment = ""
            n += 1
            line = re.sub(r'^#.*', '', line).strip()
            if line:
                try:
                    fields = line.split(None, 2)
                    action = fields[0]
                    pattern = fields[1]
                    if len(fields) > 2:
                        comment = fields[2]
                except ValueError, e:
                    sys.stderr.write("Invalid format in line %d.\n" % n)
                    sys.stderr.write(line + "\n")
                    continue
                self.actions[which][Action(action, pattern, comment)] = True
        f.close()

        self.verifyActions(which)

        self.verbose("Found the following valid action patterns:", 3)
        for action in self.actions[which].keys():
            self.verbose(action, 3)


    def printInfo(self, cve, ticket):
        for t in ticket.split():
            print "%s/browse/%s" % (self.config["url"], t)
        print cve


    def sendMail(self, pattern, recipient, jira_data, cookie):
        """Send a mail to the given recipient to let them know about the
           ticket; update the ticket saying that we sent a mail."""

        ticket = jira_data["key"]
        self.verbose("Sending mail to %s re ticket %s..." % (recipient, ticket), 4)

        summary = jira_data["fields"]["summary"]
        description = jira_data["fields"]["description"]

        smtp_from = "cvebot@twitter.com"
        smtp_to = recipient
        body = """
Hello!

We recently were notified of a vulnerability in software matching the
pattern "%s".

I thought you might be interested in this.

Please have a look -- the ticket in question is:

%s/browse/%s -- %s

%s

Thank you, and remember to be excellent to each other and party on.

--
Please don't shoot the messenger.  I'm just a simple bot, configured to
send you a mail about this sort of event.  If you have questions about
this functionality, please see http://go/cvedb and/or contact
security-team@twitter.com
""" % (pattern, self.config["url"], ticket, summary, description)
        msg = MIMEText(body)
        msg['Subject'] = "%s: %s" % (ticket, summary)
        msg['From'] = smtp_from
        msg['To'] = smtp_to

        if self.config["debug"]:
            print msg.as_string()
        else:
            try:
                s = smtplib.SMTP('localhost')
                s.sendmail(smtp_from, [smtp_to], msg.as_string())
                s.quit()
            except Exception, e:
                sys.stderr.write("Unable to send mail: %s\n" % e.strerror)
                return

        comment = "Sent mail to %s." % recipient
        self.addCommentToTicket(comment, ticket, cookie)


    def setConfigOption(self, key, val):
        """Set a configuration option."""
        self.config[key] = val
        self.frobbed[key] = True


    def setDefaultUserAndPassword(self):
            try:
                self.config["username"] = os.environ["USER"]
            except KeyError, e:
                pass
            if os.environ.has_key("NVDXJIRA_USER"):
                self.setConfigOption("username", os.environ["NVDXJIRA_USER"])
            if os.environ.has_key("NVDXJIRA_PASSWORD"):
                self.setConfigOption("password", os.environ["NVDXJIRA_PASSWORD"])


    def olderThan(self, timestamp, threshold):
        """Return True if the timestamp is older than threshold,
           False otherwise."""

        self.verbose("Checking if given timestamp is older than %d seconds..." % threshold, 4)
        if not timestamp:
            # Wat.
            return True

	# Timestamps include zone information; since strptime doesn't
	# support %z, we strip off tz information.  I don't think this is
	# pretty.
        stripped = timestamp.rpartition("+")[0]
        if not stripped:
            stripped = timestamp.rpartition("-")[0]
        timestamp = datetime.datetime.strptime(stripped, "%Y-%m-%dT%H:%M:%S.%f")

        now = datetime.datetime.utcnow()
        diff = now - timestamp
        if diff.total_seconds() > threshold:
            return True

        return False


    def updateExistingTickets(self, cookie):
        """Fetch all unresolved tickets and update them as needed.
           This involves:
             - apply software actions if any are found in the ticket
             - assign unassigned tickets for triaging
             - nag ticket owners
         """

        self.verbose("Updating existing tickets...")

        cve_pattern = re.compile("(?P<cve_id>CVE-[0-9]+-[0-9]+)")

        tickets = TICKETS
        if not tickets:
            # Warning: magic number!  We arbitrarily claim that we should not
            # have more than 10K tickets that require attention.
            tickets = self.getTickets("project=%s%%20AND%%20resolution=Unresolved&maxResults=10000&fields=*all" %
                                          self.config["project"], cookie)

        for jira_data in tickets:
            ticket = jira_data["key"]
            self.verbose("Updating existing ticket %s..." % ticket, 2)

            swlist = self.getSoftwareListFromTicketData(jira_data)
            self.applySoftwareActions(swlist, jira_data, cookie)
            self.applyLabelActions(jira_data, cookie)

            m = cve_pattern.search(jira_data["fields"]["summary"])
            if m:
                self.linkExistingTickets(ticket, m.group("cve_id"), cookie)

            updated = jira_data["fields"]["updated"]

            if not jira_data["fields"]["assignee"] and \
                self.olderThan(updated, self.config["assign-threshold"]):
                assignee = self.getNewTicketOwner()
                if assignee:
                    self.assignTicket(ticket, assignee, cookie, "Please investigate (see http://go/cve-triaging).")

            if self.olderThan(updated, self.config["nag-threshold"]):
                 comment = "This ticket could use some love.  Please consider this a friendly reminder to review this ticket and take the appropriate action."
                 self.addCommentToTicket(comment, ticket, cookie)


    def updateTicket(self, cve, ticket_data, cookie):
        """If a given ticket is missing the details found in the CVE,
           update it."""

        key = ticket_data["key"]
        open_states = [ "Open", "Reopened" ]

        self.verbose("Updating ticket %s..." % key, 2)

        # newly created tickets may not have all the data
        if not ticket_data.has_key("fields"):
            ticket_data = self.getTicketData(key, cookie)

        if ticket_data["fields"]["status"]["name"] not in open_states:
            self.verbose("Ticket %s is not open; not updating." % key, 2)
            return

        if self.closeIfRejected(cve.data, key, cookie):
            return

        self.updateTicketDetails(cve, ticket_data, cookie)
        self.applySoftwareActions(cve.data["vulnerable-software-list"], ticket_data, cookie)
        self.applyLabelActions(ticket_data, cookie)


    def updateTicketDetails(self, cve, jira_data, cookie):
        """Update the given ticket with all the details from the given
           CVE."""

        key = jira_data["key"]
        self.verbose("Updating ticket %s with details from %s." % (key, cve.data["id"]), 3)

        labels = jira_data["fields"]["labels"]
        summary = jira_data["fields"]["summary"]

        # We're taking a bit of a shortcut here: we know that when all
        # details are available at ticket creation time, then it will get
        # a CVSS score label.  If that label is missing, then we did not
        # have any details, so we can blindly update all details now.
        if not cve.data["score"]:
            self.verbose("No details found for %s; not updating." % cve.data["id"], 2)
            return

        cvss_label = "cvss-%s" % cve.data["score"]
        cvss_summary = "(CVSS: %s)" % cve.data["score"]

        if cvss_label not in labels:
            url = self.config["url"] + self.config["apiurl"] + "issue/" + key
            summary += " " + cvss_summary
            comment = "Additional details:\n\n{noformat}\n%s\n{noformat}\n" % cve
            self.addCommentToTicket(comment, key, cookie)
            data = {
                "update" : {
                    "summary"   : [
                        {
                            "set"     : summary
                        }
                    ],
                    "labels"    : [
                        {
                            "add" : cvss_label
                        }
                    ]
                }
            }
            res = self.jiraRequest(url, data, cookie, "PUT")


    def verbose(self, msg, level=1):
        """Print given message to STDERR if the object's verbosity is >=
        the given lefel."""

        if (self.verbosity >= level):
            sys.stderr.write("%s> %s\n" % ('=' * level, msg))


    def verifyActions(self, which):
        """Verify that all actions are valid and supported.
           Invalid actions are removed."""

        self.verbose("Verifying all given actions are sane...", 2)
        for action in self.actions[which].keys():
            ok = False
            self.verbose("Verifying action '%s'..." % action.action, 3)
            for pattern in SUPPORTED_ACTIONS[which].keys():
                if action.action.startswith(pattern):
                    ok = True
            if not ok:
                sys.stderr.write("Invalid action '%s'.\n" % action.action)
                self.actions[which].pop(action)


class Action(object):

    def __init__(self, action, pattern, comment=None):
        """Construct a software action object with default values."""
        self.action = action
        self.pattern = pattern
        self.comment = comment


    def __repr__(self):
        descr = "%s : %s" % (self.action, self.pattern)
        if self.comment:
            descr += " (%s)" % self.comment

        return descr


###
### "Main"
###

if __name__ == "__main__":
    try:
        nvdXjira = NVDXJIRA()
        nvdXjira.setDefaultUserAndPassword()

        try:
            nvdXjira.parseOptions(sys.argv[1:])
        except nvdXjira.Usage, u:
            if (u.err == EXIT_FAILURE):
                out = sys.stderr
            else:
                out = sys.stdout
            out.write(u.msg)
            sys.exit(u.err)
            # NOTREACHED

        nvdXjira.parseConfigFile()
        nvdXjira.parseRejectFile()

        if nvdXjira.config["label-actions"]:
            nvdXjira.parseActionsFile("label-actions")
        if nvdXjira.config["swactions"]:
            nvdXjira.parseActionsFile("swactions")

        cookie = nvdXjira.getJiraCookie()

        if nvdXjira.config["update"]:
            nvdXjira.updateExistingTickets(cookie)
        else:
            nvdXjira.createOrUpdateTickets(cookie)

    except KeyboardInterrupt:
        # catch ^C, so we don't get a "confusing" python trace
        sys.exit(EXIT_FAILURE)
